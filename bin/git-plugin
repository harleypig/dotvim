#!/bin/bash

##############################################################################
# Utility

#-----------------------------------------------------------------------------
warn() { printf '%s\n' "$@" >&2; }

die() {
  (($#)) && warn "$@"
  exit 1
}

#-----------------------------------------------------------------------------
declare -A known
declare self

known['add']='_add'
known['move']='_mv'
known['remove']='_rm'
known['update']='_update'

known['a']='_add'
known['m']='_mv'
known['r']='_rm'
known['u']='_update'

self="${0##*\/git-plugin-}"

[[ $self == "$0" ]] && { self="$1" && shift; }
[[ $self == '' ]] && die "bad link"

[[ -v known[$self] ]] || die "unknown option '$self'"

#-----------------------------------------------------------------------------
_mkreadme() {
  [[ -z $1 ]] && die 'must pass comment to use for commit message'
  commit_msg="$1"
  mkreadme > README.md
  git add README.md
  git commit -m "Updated README.md; $commit_msg" README.md
}

#-----------------------------------------------------------------------------
_get_path() {
  [[ -z $1 ]] && die 'must pass name of submodule path to find'
  local name="$1"
  local modpath
  read -r modpath < <(git config -f .gitmodules --get "submodule.${name}.path")
  printf '%s' "$modpath"
}

##############################################################################
#-----------------------------------------------------------------------------
_update() {
  [[ -z $1 ]] && die 'must pass name of submodule to update'
  local name="$1"

  path="$(_get_path "$name")"
  [[ -z $path ]] && die "$name is not a submodule"
  git submodule update --init --recursive "$path"
  _mkreadme "updated $name"
}

#-----------------------------------------------------------------------------
_add() {
  [[ -z $1 ]] && die 'must pass git url of submodule to add'
  local url="$1"

  local name="${url##*/}"
  name="${name,,}"
  name="${name%\.git}"
  name="${name%\.vim}"
  name="${name%\.nvim}"

  local modpath
  modpath="$(_get_path "$name")"
  [[ -n $modpath ]] && die "$name already exists in .gitmodules"
  modpath=".vim/pack/testing/start/$name"

  git submodule add --name "$name" "$url" "$modpath"
  git config -f .gitmodules "submodule.${name}.ignore" 'dirty'
  git add .gitmodules
  git commit -m "auto commit of .gitmodules after adding $name"

  _update $name

  _mkreadme "added $name"
}

#-----------------------------------------------------------------------------
_mv() {
  [[ -z $1 ]] && die 'must pass name of submodule to be moved'
  [[ -z $2 ]] && die 'must pass new location to move submodule to'

  local name="$1"
  local newloc="$2"

  local oldpath
  oldpath="$(_get_path "$name")"
  [[ -z $oldpath ]] && die "$name is not a submodule"

  newpath=".vim/pack/$newloc/start"
  [[ $newpath == "$oldpath" ]] && die "$name is alread in $newloc"
  [[ -d $newpath ]] || die "$newpath does not exist, create it and try again"

  git mv "$oldpath" "$newpath/$name"
  # needed?
  git add "$newpath/$name"
  git commit -m "auto commit of moved files for $name"

  _mkreadme "moved $name to $newloc"
}

#-----------------------------------------------------------------------------
_rm() {
  [[ -z $1 ]] && die 'must pass name of submodule to be removed'
  local name="$1"
  
  path="$(_get_path "$name")"
  [[ -z $path ]] && die "$name is not a submodule"
  
  git rm -r "$path" || die "Problem removing $name"
  rm -fr ".git/modules/${path##*/}"
  git config --remove-section "submodule.$name"
  git commit -m "auto commit of removed files for $name"

  _mkreadme "removed $name"
}

#-----------------------------------------------------------------------------
"${known[$self]}" "$@"
